# 🔍 二分查找模板总结（含左中位与右中位）

下面是一个**通用二分查找模板合集**，涵盖「左中位」「右中位」两种形式，以及典型应用场景。
你可以直接套用来写所有 LeetCode 上的二分题。

---

## 🔹模板 1：找 **第一个满足条件** 的位置（左边界模板）

**适用场景**：

* 找最左边满足条件的元素
* 如「第一个大于等于 target 的位置」、「第一个错误的版本」等

```python
def binary_search_left(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2  # ✅ 左中位
        if nums[mid] < target:
            left = mid + 1          # 还没达到目标，向右
        else:
            right = mid              # mid 可能是答案，保留
    return left  # 最左满足条件的位置
```

🧩 示例：
nums = [1, 2, 4, 4, 5], target = 4
→ 返回 index 2（第一个 ≥ 4 的位置）

---

## 🔹模板 2：找 **最后一个满足条件** 的位置（右边界模板）

**适用场景**：

* 找最右边满足条件的元素
* 如「最后一个小于等于 target 的位置」、「最大合法值」等

```python
def binary_search_right(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right + 1) // 2  # ✅ 右中位
        if nums[mid] <= target:
            left = mid                  # mid 可行，向右靠
        else:
            right = mid - 1
    return left  # 最右满足条件的位置
```

🧩 示例：
nums = [1, 2, 4, 4, 5], target = 4
→ 返回 index 3（最后一个 ≤ 4 的位置）

---

## 🔹模板 3：找最大满足条件的整数（上界整数二分）

**适用场景**：

* 例如「最大 k 使得 k(k+1)/2 ≤ n」
* 常用于数学类题（如 LeetCode 441、Sqrt(x)）

```python
def find_max_ok(n):
    left, right = 0, n
    while left < right:
        mid = (left + right + 1) // 2  # ✅ 右中位
        if mid * (mid + 1) // 2 <= n:  # 满足条件，mid 可行
            left = mid
        else:
            right = mid - 1
    return left  # 最大满足条件的整数
```

---

## 🔹模板 4：标准查找值（精确匹配）

**适用场景**：

* 数组有序，找 target 是否存在

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:           # 注意这里用 <=
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # 没找到
```

---

## 🧭 快速记忆法则

| 目标        | mid 取法           | 条件满足时的动作      | 返回值      |
| --------- | ---------------- | ------------- | -------- |
| **找最左边界** | 左中位 `(l+r)//2`   | `right = mid` | left     |
| **找最右边界** | 右中位 `(l+r+1)//2` | `left = mid`  | left     |
| **找精确匹配** | 任意               | 比较后移动两边       | mid / -1 |

---

## 🚀 实战建议

* 一旦确定目标是「最大满足条件」 → 用 **右中位模板**
* 一旦确定目标是「最小满足条件」 → 用 **左中位模板**
* 一旦目标是「是否存在某值」 → 用 **标准模板**

---

## 🎯 一句话记忆

> * **左中位 = 找最左**
> * **右中位 = 找最右**
> * **满足条件 → 收缩相反方向的边界**

---

## 📊 模板对比表

| 功能              | 区间                    | mid          | 条件判断             | 返回         |
| --------------- | --------------------- | ------------ | ---------------- | ---------- |
| 找第一个满足条件的（左边界）  | `while left < right`  | `(l+r)//2`   | 满足条件：`right=mid` | `left`     |
| 找最后一个满足条件的（右边界） | `while left < right`  | `(l+r+1)//2` | 满足条件：`left=mid`  | `left`     |
| 找精确值            | `while left <= right` | `(l+r)//2`   | 等于返回，否则移动        | `mid / -1` |

---

## 💬 提示

想进一步理解每一步的区间收缩逻辑？
我可以为你生成「左中位 vs 右中位」的可视化动图（展示每轮 left、mid、right 的变化过程），帮助你彻底掌握二分查找。
